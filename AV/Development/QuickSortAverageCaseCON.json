{
  "translations" :{
    "en": {
	  "Slide 1": "QuickSort is a recursive function, accordingly we should end up with a recursive relation to describe its average case running time",
	  "Slide 2": "For an array of size $n$, the partition function can cause the pivot to be at any position $k$ from $0$ to $n-1$",
	  "Slide 3": "Accordingly, there will be two recursive calls for the quicksort function, one for the left $k$ elements that will take $T(k)$ time and the other for the right $n-1-k$ elements that will take $T(n-1-k)$ time",
	  "Slide 4_1": "Consider the following cases for $k$:",
	  "Slide 4_2": "If the pivot ends in position $0$, the total running time will be $cn+T(0)+T(n-1)$, where $cn$ here stands for the cost of the partition step",
	  "Slide 5": "If the pivot ends in position $1$, the total running time will be $cn+T(1)+T(n-2)$",
	  "Slide 6": "If the pivot ends in position $2$, the total running time will be $cn+T(2)+T(n-3)$",
	  "Slide 7": "If the pivot ends in position $3$, the total running time will be $cn+T(3)+T(n-4)$",
	  "Slide 8": "We make one reasonable simplifying assumption: At each partition step, the pivot is equally likely to end in any position in the array",
	  "Slide 9": "And since we have $n$ positions, therefore the average cost of the recursive calls can be modeled as: ",
	  "Slide 10": "But also we need to add the cost for the partition and findpivot functions which is $cn$ for some constant $c$",
	  "Slide 11": "Accordingly, quicksort's average running time can be modeled by the following recurrence:",
	  "Slide 12": "By solving this recurrence, we will have that quicksort's average running time is $\\theta(n\\log{n})$"
    }
  }
}
