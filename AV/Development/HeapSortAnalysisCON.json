{
  "translations" :{
    "en": {
	  "Slide 1": "The first step in heapsort is to heapify the array. This will cost $\\theta(n)$ running time for an array of size $n$.<br> Consider the following structure of a Max Heap",
	  "Slide 2": "HeapSort swaps the root node containng the maximum key with the last node in the heap",
	  "Slide 3": "After swapping, the heap size is reduced by $1$ and the Max-heap property may be violated, accordingly, the array should be re-heapified",
	  "Slide 4": "In the worst case, siftdown will push the root node towards the current last position in the heap",
	  "Slide 8": "This will requires $\\lfloor\\log{i}\\rfloor$ amount of work, where $i$ is the index of the current last position in the heap",
	  "Slide 9": "Since this process is done till the heap is empty, the total amount of work can be modeled by the following summation",
	  "Slide 10": "Since most of the heap nodes are located towards the bottom of the heap, the distance from the root to the current last position in the heap will be in most cases $\\lfloor\\log{n}\\rfloor$, thus this summation is bounded by $n\\log{n}$",
	  "Slide 11": "Accordingly, the total running time of heapsort is $\\theta(n+n\\log{n}) = \\theta(n\\log{n})$",
	  "Slide 12": "If all key values were equal, then Heapsort would cost $\\theta(n)$ in be best case because every call to removemax would result in calls to siftdown that complete in constant time because the new root value never swaps with its children."
    }
  }
}
